---
# If true, the FSM transitions are managed by an external tool
Managed: false
# If true and the FSM is self-managed, transitions should be triggered
StepByStep: true
# Change idle behaviour, if true the state is kept until transition,
# otherwise the FSM holds the last state until transition
IdleKeepState: false
# Where to look for state libraries
StatesLibraries:
- "@MC_STATES_DEFAULT_RUNTIME_INSTALL_PREFIX@"
- "@MC_STATES_RUNTIME_INSTALL_PREFIX@"
- "@XSENS_PLUGIN_STATES_LIBRARIES@"
# Where to look for state files
StatesFiles:
- "@MC_STATES_DEFAULT_RUNTIME_INSTALL_PREFIX@/data"
- "@MC_STATES_RUNTIME_INSTALL_PREFIX@/data"
- "@XSENS_PLUGIN_STATES_FILES@"
# If true, state factory will be more verbose
VerboseStateFactory: false

# Initial position of main robot (still needed for mujoco)
# We update it in the reset state to place robot and chair depending on the human
init_pos:
  # translation: [0, -1, 0.77] # e2dr
  translation: [0, -1, 0.75] # hrp4

Limits:
  hrp4:
    # Lower joint limits for knees to prevent overstretching
    R_KNEE_P:
      lower: 0.411
    L_KNEE_P:
      lower: 0.411

# Additional robots to load
robots:
  chair:
    module: env/chair
    # init_pos:
    #   translation: [-0.27, 0.36, 0.0] # orig pose of hips here is [-0.37, 0.36, 0.0], we apply offset of [0.1, 0.0, 0.0]
  human:
    module: human
    init_pos:
      translation: [-0.37, 0.36, 0.66]
  ground:
    module: env/ground
  panda:
    module: PandaHelpUp
    frames:
      - name: HumanBack
        parent: panda_link7
        X_p_f:
          translation: [0.07, 0, 0.25]
          rotation: [0.0, 1.57, 0.0]

# General constraints, always on
constraints:
- type: contact
- type: kinematics
  damper: [0.1, 0.01, 0.5]
  velocityPercent: 0.5
- type: compoundJoint
- type: kinematics
  robot: panda
  damper: [0.1, 0.01, 0.5]
  velocityPercent: 0.5
# - type:  dynamics
#   damper: [0.1, 0.01, 0.5]
# - type:  dynamics
#   robot: human
#   infTorque: true
#   damper: [0.1, 0.01, 0.5]


# Collision constraint
collisions:
- type: collision
  useMinimal: true
- type: collision
  r1: panda
  r2: panda
  useMinimal: true
- type: collision
  r1: hrp4 #e2dr
  r2: human
  collisions:
    # robot left arm collision with human torso important links are L_ELBOW_P_LINK L_WRIST_Y_LINK l_wrist
    - body1: L_ELBOW_P_LINK
      body2: TorsoLink
      iDist: 0.03
      sDist: 0.001
      damping: 0
    - body1: L_WRIST_Y_LINK
      body2: TorsoLink
      iDist: 0.03
      sDist: 0.001
      damping: 0
    - body1: l_wrist
      body2: TorsoLink
      iDist: 0.003
      sDist: 0.0001
      damping: 0
#     # robot right wrist collision with human torso and right arm
#     - body1: r_wrist
#       body2: TorsoLink
#       iDist: 0.003
#       sDist: 0.0001
#       damping: 0
#     - body1: r_wrist
#       body2: RArmLink
#       iDist: 0.03
#       sDist: 0.001
#       damping: 0
#     - body1: r_wrist
#       body2: RForearmLink
#       iDist: 0.03
#       sDist: 0.001
#       damping: 0
#     # robot right forearm collision with human torso and right arm
#     - body1: R_WRIST_Y_LINK
#       body2: TorsoLink
#       iDist: 0.03
#       sDist: 0.001
#       damping: 0
#     - body1: R_WRIST_Y_LINK
#       body2: RArmLink
#       iDist: 0.03
#       sDist: 0.001
#       damping: 0
#     - body1: R_WRIST_Y_LINK
#       body2: RForearmLink
#       iDist: 0.03
#       sDist: 0.001
#       damping: 0
#     - body1: R_ELBOW_P_LINK
#       body2: TorsoLink
#       iDist: 0.03
#       sDist: 0.001
#       damping: 0
#     - body1: R_ELBOW_P_LINK
#       body2: RArmLink
#       iDist: 0.03
#       sDist: 0.001
#       damping: 0
#     - body1: R_ELBOW_P_LINK
#       body2: RForearmLink
#       iDist: 0.03
#       sDist: 0.001
#       damping: 0




# Initial set of contacts hrp4
# contacts:
# - r1: hrp4
#   r2: ground
#   r1Surface: LeftFoot
#   r2Surface: AllGround
#   dof: [0.0, 0.0, 1.0, 1.0, 1.0, 0.0]
# - r1: hrp4
#   r2: ground
#   r1Surface: RightFoot
#   r2Surface: AllGround
#   dof: [0.0, 0.0, 1.0, 1.0, 1.0, 0.0]
# - r1: human
#   r2: ground
#   r1Surface: LeftSole_ForceShoe
#   r2Surface: AllGround
#   dof: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
# - r1: human
#   r2: ground
#   r1Surface: RightSole_ForceShoe
#   r2Surface: AllGround
#   dof: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
# - r1: human
#   r2: chair
#   r1Surface: RCheek
#   r2Surface: Top
# - r1: human
#   r2: chair
#   r1Surface: LCheek
#   r2Surface: Top


# Initial set of contacts e2dr
# contacts:
# - r1: e2dr
#   r2: ground
#   r1Surface: LeftFoot
#   r2Surface: AllGround
#   dof: [0.0, 0.0, 1.0, 1.0, 1.0, 0.0]
# - r1: e2dr
#   r2: ground
#   r1Surface: RightFoot
#   r2Surface: AllGround
#   dof: [0.0, 0.0, 1.0, 1.0, 1.0, 0.0]
# - r1: human
#   r2: ground
#   r1Surface: LeftSole
#   r2Surface: AllGround
#   dof: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
# - r1: human
#   r2: ground
#   r1Surface: RightSole
#   r2Surface: AllGround
#   dof: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
# # - r1: human
# #   r2: chair
# #   r1Surface: RCheek
# #   r2Surface: Top
# # - r1: human
# #   r2: chair
# #   r1Surface: LCheek
# #   r2Surface: Top

# Some options for a specific robot
e2dr:
  posture:
    stiffness: 1
    weight: 10

human:
  posture:
    stiffness: 1
    weight: 10

hrp4:
  posture:
    stiffness: 1
    weight: 10


# Force limit on contacts (if not here, considered support contact and max force is m*g)
# todo : differenciate human and robot
surfacesMaxForces:
  # LeftFoot: 850 # e2dr weights 87.27kg
  # RightFoot: 850
  LeftFoot: 500
  RightFoot: 500
  LeftHand: 15
  RightHand: 15
  RLegBack: 500
  LLegBack: 500
  LeftSole: 500
  RightSole: 500
  RightShoulder: 15
  Back: 15
  LCheek: 500
  RCheek: 500

# FSM states
states:

  ResetStateHRP4:
    base: ResetPoses
    chairOffset: # in world frame
      translation: [0.1, 0.0, 0.0]
      rotation: [0.0, 0.0, 0.0]
    robotOffset: # in chair frame
      # translation: [0.2, -0.55, 0.75]
      translation: [0.1, -0.55, 0.75]
      rotation: [0.0, 0.0, 1.6]
    pandaOffset: # in chair frame
      translation: [0.3, 0.6, 0.725]
      rotation: [0.0, 0.0, -1.57]
    AddContactsAfter:
      - r1: hrp4
        r2: ground
        r1Surface: LeftFoot
        r2Surface: AllGround
        dof: [0.0, 0.0, 1.0, 1.0, 1.0, 0.0]
      - r1: hrp4
        r2: ground
        r1Surface: RightFoot
        r2Surface: AllGround
        dof: [0.0, 0.0, 1.0, 1.0, 1.0, 0.0]

# These are the stabilizer FSM states
  GeneralRobotStabilizer:
    base: RobotStabilizer
    # stiffness and StabilizerConfig are optional but expliciting them makes it easier to change here
    stiffness: 5
    StabilizerConfig:
      type: lipm_stabilizer
      tasks:
        # com:
        #   activeJoints: []
        torso:
          stiffness: 0
          weight: 0
      enabled: true
      contacts: [Left, Right] # This uses right and left contact from robot module so ok for any robot that defined them
      admittance:
        maxVel:
          linear: [0.3,0.3,0.3]
          angular: [0.5,0.5,0.5]
      Left:
        # Keep the yaw intact, align roll/pitch with the (flat) ground
        overwriteRPY:
          roll: 0
          pitch: 0
        height: 0
      Right:
        overwriteRPY:
          roll: 0
          pitch: 0
        height: 0
    ExternalWrenchConfig:
      addExpectedCoMOffset: true # adds a feedforward term to target com movement from target external forces (false if ext forces are taken into account by pattern gen)
      substractMeasuredValue: false # substract the measured values instead of the target ones for offset computation (takes gains into account)
      ext_wrench_sum_cutoff: 0.8 # instead of 0.05: low pass filter of the measured ext wrenches (we lower the low-pass)
      modifyCoMErr: true # for low frequency errors
      com_offset_cutoff: 0.8 # cutoff for zmp strategy: 0.8 instead of 0.05, we lower the low pass
      modifyZMPErr: false # for high frequency errors
      com_offset_com_cutoff: 1.0 # cutoff for com strategy
      modifyZMPErrD: false # derivative of the external force error, should be true in theory but highly affected by measurement noise
      excludeFromDCMBiasEst: true # if com bias estimator is used, should be true to exclude ext forces from estimation (otherwise taken into account twice)
    DCMBiasEstimatorConfig:
      withDCMBias: true
      withDCMFilter: false
      correctCoMPos: false # whether to unbias the absolute CoM position

  RobotStabilizer::GoCenter:
    base: ChangeBalanceConfig
    StabilizerConfig:
      contacts: [Right, Left]
    above: CenterSurfaces
    completion:
      dcmEval: [0.003, 0.003, 0.05]
    stayManualAfter: false

  RobotStabilizer::GoLeft:
    base: ChangeBalanceConfig
    above: LeftSurface
    completion:
      dcmEval: [0.003, 0.003, 0.05]

  RobotStabilizer::LeftSupport:
    base: ChangeBalanceConfig
    # completion: {}
    StabilizerConfig:
      contacts: [Left]

  RobotStabilizer::GoRight:
    base: ChangeBalanceConfig
    above: RightSurface
    completion:
      dcmEval: [0.003, 0.003, 0.05]

  RobotStabilizer::RightSupport:
    base: RobotStabilizer::GoRight
    completion: {}
    StabilizerConfig:
      contacts: [Right]

# This state makes the step to the right while keeping the CoM above the left contact
  RobotStabilizer::MakeRightStepHRP4:
    base: Parallel
    states: [RobotStabilizer::LeftSupport, RightFootExtendHRP4]

  # This state lifts up the right foot while keeping the CoM above the left contact
  RobotStabilizer::MakeRightLiftHRP4:
    base: Parallel
    states: [RobotStabilizer::LeftSupport, RightFootLiftHRP4]
    RemoveContacts:
      - r1: hrp4
        r2: ground
        r1Surface: RightFoot
        r2Surface: AllGround

  RightFootLiftHRP4:
    base: MetaTasks
    tasks:
      LiftRightFoot:
        type: transform
        stiffness: 10.0
        weight: 500.0
        frame: RightFoot
        completion:
          # OR:
          eval: 0.015
            # - AND:
            #   - timeout: 3
            #   - speed: 0.005
        # We target 10cm up
        moveWorld:
          translation: [0,0,0.1]


  RightFootExtendHRP4:
    base: MetaTasks
    tasks:
      ExtendFootTask:
        type: bspline_trajectory
        stiffness: 50.0
        weight: 500.0
        duration: 3.0
        frame: RightFootCenter
        completion:
          OR:
            - timeElapsed: true
            - wrench: [.NaN, .NaN, .NaN, .NaN, .NaN, 20]
        # We target the left foot translated 30cm right
        targetFrame:
          robot: hrp4
          frame: LeftFoot
          translation: [0.0, -0.3, 0]
          rotation: [0.0, 0.0, 0.0]
        controlPoints:
          - [0.0, -0.2, 0.1]
    AddContactsAfter:
      - r2: ground
        r1Surface: RightFoot
        r2Surface: AllGround
        dof: [0, 0, 1, 1, 1, 0]

  TakePositionE2DR:
    base: MetaTasks
    tasks:
      RHandTrajectory:
        type: bspline_trajectory
        robot: e2dr #e2dr hrp4
        frame: RightHand #Flat
        weight: 500.0
        stiffness: 1000.0
        duration: 3.0
        targetFrame:
          robot: human
          frame:  RightShoulder #Chest
          translation: [0.0, 0.0, 0.05]
          # controlPoints:
          #   - [-0.2, 0.2, 0.2]
      LHandTrajectory:
        type: bspline_trajectory
        robot: e2dr #e2dr hrp4
        frame: LeftHand #Flat
        weight: 500.0
        stiffness: 1000.0
        duration: 3.0
        targetFrame:
          robot: human
          frame: Back
          translation: [0.0, 0.0, 0.05]
          # controlPoints: # in target frame !
          #   - [-0.2, -0.2, 0.2]
    # RemoveCollisionsAfter:
    #   - r1: e2dr
    #     r2: human
    #     collisions:
    #       - body1: l_wrist
    #         body2: TorsoLink
    #         iDist: 0.003
    #         sDist: 0.0001
    #         damping: 0
    #       - body1: r_wrist
    #         body2: TorsoLink
    #         iDist: 0.003
    #         sDist: 0.0001
    #         damping: 0
    AddContactsAfter: # here the contact constraint added is on the x and y axis to keep position
      - r1: e2dr
        r2: human
        r1Surface: RightHand
        r2Surface: RightShoulder
        dof: [0.0, 0.0, 1.0, 1.0, 1.0, 0.0] # last one is z axis
      - r1: e2dr #e2dr hrp4
        r2: human
        r1Surface: LeftHand
        r2Surface: Back
        dof: [0.0, 0.0, 1.0, 1.0, 1.0, 0.0]

  TakePositionHRP4:
    base: RobotTakePoseObserved
    RHandTrajectory:
      type: bspline_trajectory
      robot: hrp4
      frame: RightHand
      weight: 10000.0
      stiffness: 300
      duration: 5.0
      targetFrame:
        robot: human
        frame:  RightShoulder
        # translation: [0.0, 0.0, 0.02]
        controlPoints:
          - [0, 0, 0.1]
      completion:
        OR:
          - wrench: [.NaN, .NaN, .NaN, .NaN, .NaN, 10]
          - AND:
              - eval: 0.02
              - speed: 0.01
    LHandTrajectory:
      type: bspline_trajectory
      robot: hrp4
      frame: LeftHand
      weight: 10000.0
      stiffness: 300
      duration: 5.0
      targetFrame:
        robot: human
        frame: Back
        # translation: [0.0, 0.0, 0.02]
        controlPoints: # in target frame !
          - [0, 0, 0.3]
      completion:
        OR:
          - wrench: [.NaN, .NaN, .NaN, .NaN, .NaN, 10]
          - AND:
              - eval: 0.02
              - speed: 0.01
    RemoveCollisionsAfter:
      - r1: hrp4
        r2: human
    # AddContactsAfter:
    #   - r1: hrp4
    #     r2: human
    #     r1Surface: RightHand
    #     r2Surface: RightShoulder
    #     # dof: [1.0, 1.0, 1.0, 1.0, 1.0, 0.0]
    #   - r1: hrp4
    #     r2: human
    #     r1Surface: LeftHand
    #     r2Surface: Back
    #     # dof: [1.0, 1.0, 1.0, 1.0, 1.0, 0.0]



  MakeHandContactsE2DR:
    base: MetaTasks
    tasks:
      RHCoP:
        type: cop
        frame: RightHand
        targetFrame:
          robot: human
          frame: RightShoulder
        force: [0.0, 0.0, 10.0]
        admittance:
          couple: [0.005, 0.005, 0.0]
          force: [0.0, 0.0, 0.005]
      # RHAdmi:
      #   type: admittance
      #   frame: RightHand
      #   stiffness: [10, 10, 10, 10, 10, 1]
      #   damping: [6.3, 6.3, 6.3, 6.3, 6.3, 300]
      #   targetFrame:
      #     robot: human
      #     frame: RightShoulder
      #   wrench:
      #     couple: [0.0, 0.0, 0.0]
      #     force: [0.0, 0.0, 10.0]
      #   admittance:
      #     couple: [0.0, 0.0, 0.0]
      #     force: [0.0, 0.0, 0.001]
      #   completion:
      #       wrench:
      #         couple: [0.0, 0.0, 0.0]
      #         force: [0.0, 0.0, 5.0]
      LHCoP:
        type: cop
        frame: LeftHand
        targetFrame:
          robot: human
          frame: Back
        force: [0.0, 0.0, 10.0]
        admittance:
          couple: [0.005, 0.005, 0.0]
          force: [0.0, 0.0, 0.005]
      # LHAdmi:
      #   type: admittance
      #   frame: LeftHand
      #   stiffness: [10, 10, 10, 10, 10, 1]
      #   damping: [6.3, 6.3, 6.3, 6.3, 6.3, 300]
      #   targetFrame:
      #     robot: human
      #     frame: Back
      #   wrench:
      #     couple: [0.0, 0.0, 0.0]
      #     force: [0.0, 0.0, 10.0]
      #   admittance:
      #     couple: [0.0, 0.0, 0.0]
      #     force: [0.0, 0.0, 0.001]
      #   completion:
      #       wrench:
      #         couple: [0.0, 0.0, 0.0]
      #         force: [0.0, 0.0, 5.0]
    AddContactsAfter: # here the contact constraint is added on the first 3 dofs as well after adapting with CoP task
      - r1: e2dr
        r2: human
        r1Surface: RightHand
        r2Surface: RightShoulder
        dof: [0.0, 0.0, 1.0, 1.0, 1.0, 0.0]
      - r1: e2dr
        r2: human
        r1Surface: LeftHand
        r2Surface: Back
        dof: [0.0, 0.0, 1.0, 1.0, 1.0, 0.0]



  KeepPositionHRP4:
    base: RobotHolding
    # weight: 10000
    # stiffness: 1500
    # robot: hrp4
    RightHandImped:
      type: impedance
      frame: RightHand
      targetFrame:
        robot: human
        frame: RightShoulder
      weight: 10000.0
      stiffness: 40
      wrench:
        couple: [0.0, 0.0, 0.0]
        force: [0.0, 0.0, 10.0]
      gains:
        mass:
          angular: [10, 10, 10]
          linear: [10, 10, 10]
        damper:
          angular: [1000, 1000, 1000]
          linear: [1000, 1000, 1000]
        spring:
          angular: [1000, 1000, 1000]
          linear: [1000, 1000, 10]
        wrench:
          angular: [0, 0, 0]
          linear: [0, 0, 1]
      completion:
        OR:
          - wrench: [.NaN, .NaN, .NaN, .NaN, .NaN, 20]
          - AND:
              - eval: 0.015
              - speed: 0.01
    LeftHandImped:
      type: impedance
      frame: LeftHand
      targetFrame:
        robot: human
        frame: Back
        # offset:
        #   translation: [0, 0, -0.02]
        #   rotation: [0, 0, -1.57]
      weight: 10000.0
      stiffness: 40
      wrench:
        couple: [0.0, 0.0, 0.0]
        force: [0.0, 0.0, 10.0]
      gains:
        mass:
          angular: [10, 10, 10]
          linear: [10, 10, 10]
        damper:
          angular: [1000, 1000, 1000]
          linear: [1000, 1000, 1000]
        spring:
          angular: [1000, 1000, 1000]
          linear: [1000, 1000, 10]
        wrench:
          angular: [0, 0, 0]
          linear: [0, 0, 1]
      completion:
        OR:
          - wrench: [.NaN, .NaN, .NaN, .NaN, .NaN, 20]
          - AND:
              - eval: 0.015
              - speed: 0.01



  KeepPositionCompliE2DR:
    # base:
    base: MetaTasks
    tasks:
      RHandCompli:
        type: damping
        frame: RightHand
        wrench:
          couple: [0.0, 0.0, 0.0]
          force: [0.0, 0.0, 0.0]
      LHandCompli:
        type: damping
        # body: LArm_6AF
        frame: LeftHand
        wrench:
          couple: [0.0, 0.0, 0.0]
          force: [0.0, 0.0, 0.0]

  KeepPositionCompliHRP4:
    # base:
    base: MetaTasks
    tasks:
      RHandCompli:
        type: compliance
        body: r_wrist
        wrench:
          couple: [0.0, 0.0, 0.0]
          force: [0.0, 0.0, 0.0]
      LHandCompli:
        type: compliance
        body: l_wrist
        wrench:
          couple: [0.0, 0.0, 0.0]
          force: [0.0, 0.0, 0.0]


  RemoveHandsHRP4:
    base: MetaTasks
    RemoveContacts:
      - r1: hrp4 #e2dr
        r2: human
        r1Surface: LeftHand #Flat
        r2Surface: Back
      - r1: hrp4 #e2dr
        r2: human
        r1Surface: RightHand #Flat
        r2Surface: RightShoulder
    # make bsplines to get away from human
    tasks:
      RHandTrajectory:
        type: bspline_trajectory
        robot: hrp4 #e2dr
        frame: RightHand #Flat
        weight: 500.0
        stiffness: 100.0
        duration: 2.0
        targetFrame:
          robot: human
          frame: RightShoulder
          translation: [0.2, 0.5, 0]
          rotation: [0, 1.5, 0]
          controlPoints:
            - [0, 0.2, 0.2]
      LHandTrajectory:
        type: bspline_trajectory
        robot: hrp4 #e2dr
        frame: LeftHand #Flat
        weight: 500.0
        stiffness: 100.0
        duration: 2.0
        targetFrame:
          robot: human
          frame: Back
          translation: [-0.2, -0.2, 0.2]
          controlPoints:
            - [0, 0, 0.2]

  HRP4pos:
    base: MetaTasks
    tasks:
      HRP4HalfSit:
        type: posture
        robot: hrp4
        completion:
          eval: 0.01
        stiffness: 3
        weight: 1000
        target:
          R_HIP_Y: [0.0]
          R_HIP_R: [-0.02]
          # R_HIP_P: [-0.384]
          # R_KNEE_P: [0.719]
          # R_ANKLE_P: [-0.335]
          R_ANKLE_R: [0.02]
          L_HIP_Y: [0.0]
          L_HIP_R: [0.02]
          # L_HIP_P: [-0.384]
          # L_KNEE_P: [0.719]
          # L_ANKLE_P: [-0.335]
          L_ANKLE_R: [-0.02]
          CHEST_P: [0.14]
          CHEST_Y: [0.0]
          NECK_Y: [0.0]
          NECK_P: [0.0]
          R_SHOULDER_P: [-0.052]
          R_SHOULDER_R: [-0.175]
          R_SHOULDER_Y: [0.0]
          R_ELBOW_P: [-0.524]
          R_WRIST_Y: [0.0]
          R_WRIST_P: [0.0]
          R_WRIST_R: [0.0]
          L_SHOULDER_P: [-0.052]
          L_SHOULDER_R: [0.175]
          L_SHOULDER_Y: [0.0]
          L_ELBOW_P: [-0.524]
          L_WRIST_Y: [0.0]
          L_WRIST_P: [0.0]
          L_WRIST_R: [0.0]


  XsensHumanPose:
    # base: XsensHuman
    # robot: human
    # stiffness: 1000
    # weight: 10000
    base: XsensRetargetting
    robot: human
    stiffness: 1000
    weight: 10000
    Xsens:
      human:
        bodies:
          LAnkleLink:
            forceHorizontalSegment: true
          RAnkleLink:
            forceHorizontalSegment: true
    groundingFrames: [LeftSole, RightSole] ## REPLACE WITH YOUR FRAME NAMES
    fixBaseLink: false
    initialStiffnessInterpolationDuration: 0

  Pause_inf:
    base: Meta
    transitions:
      - [Pause_2s, OK, Pause_2s, Auto]

  XsensHumanPause:
    base: Parallel
    states: [XsensHumanPose, Pause_inf]


  HelpFSM_HRP4:
    base: Meta
    transitions:
    - [Pause_2s, OK, RightStepFSMHRP4, Strict]
    - [RightStepFSMHRP4, OK, TakePositionHRP4, Auto]
    # - [TakePositionHRP4, OK, MakeHandContactsHRP4, Strict]
    # - [MakeHandContactsHRP4, OK, KeepPositionHRP4, Strict]
    - [TakePositionHRP4, OK, KeepPositionHRP4, Strict]
    - [KeepPositionHRP4, OK, GoBackInitFSMHRP4, Strict]
    # - [GoBackInitHRP4, OK, HRP4pos, Strict]

  HelpFSM_E2DR:
    base: Meta
    transitions:
    - [Pause_2s, OK, TakePositionE2DR, Strict]
    - [TakePositionE2DR, OK, MakeHandContactsE2DR, Strict] #KeepPosition
    - [MakeHandContactsE2DR, OK, KeepPositionCompliE2DR, Strict]
    - [KeepPositionCompliE2DR, OK, GoBackInitHRP4, Strict]
    - [GoBackInitHRP4, OK, HRP4pos, Strict]

  HelpDemoHRP4:
    base: Parallel
    states: [XsensHumanPose, GeneralRobotStabilizer, HelpFSM_HRP4] #AddCollisionWithHuman,

  HelpDemoE2DR:
    base: Parallel
    states: [XsensHumanPose, GeneralRobotStabilizer, HelpFSM_E2DR]

  RightStepFSMHRP4:
    base: Meta
    transitions:
    - [RobotStabilizer::GoLeft, OK, RobotStabilizer::MakeRightLiftHRP4, Auto]
    - [RobotStabilizer::MakeRightLiftHRP4, OK, RobotStabilizer::MakeRightStepHRP4, Auto]
    - [RobotStabilizer::MakeRightStepHRP4, OK, RobotStabilizer::GoCenter, Auto]

  GoBackInitFSMHRP4:
    base: Meta
    transitions:
    - [RemoveHandsHRP4, OK, RobotStabilizer::GoCenter, Strict]
    - [RobotStabilizer::GoCenter, OK, HRP4pos, Auto]

# OK between the states is the transition if the state output is OK -> I can branch with
# - [StateA, Output1, StateB]
# - [StateA, Output2, StateC]
# If I change the state output

# Transitions map for human tracking
transitions:
# HRP4 version
- [ResetStateHRP4, OK, HelpDemoHRP4, Auto]
- [HelpDemoHRP4, OK, HelpDemoHRP4, Strict]

# E2DR version
# - [ResetStateE2DR, OK, HelpDemoE2DR, Auto]
# - [HelpDemoE2DR, OK, HelpDemoE2DR, Strict]



# Initial state
init: ResetStateHRP4
# init: ResetStateE2DR

# XXX For now load later because we control HRP4 with the UDPPlugin and sensor
# values are not available from the start of the controller
HRP4ObserverPipeline:
  name: MainRobPipeline                    # - Create a new pipeline
  gui: true                              #   diplay the pipeline in the GUI (default = false)
  log: true                              #   log observers (default)
  observers:                             #   declare which observers to use
  - type: Encoder                        # - Use an EncoderObserver
    config:
      robot: hrp4
      updateRobot: hrp4
      position: encoderValues            #    - Sets joint position from encoder sensor values (default)
      velocity: encoderFiniteDifferences #    - Computes joint velocities by finite differences  (default)
      computeFV: true                    # We now have the estimation of each joint position and velocity and the corresponding body positions and velocities, but we are still missing the floating base
    # config:
    #   robot: e2dr
    #   updateRobot: e2dr
    #   position: encoderValues            #    - Sets joint position from encoder sensor values (default)
    #   velocity: encoderFiniteDifferences #    - Computes joint velocities by finite differences  (default)
    #   computeFV: true
  - type: Attitude
    config:
      bodySensor: Accelerometer
  - type: KinematicInertial              # - Estimates the floating base state using the KinematicInertial observer
    update: true                         #   update the real robot instance from its results
    gui: true                            #   Displays the estimated velocity as an arrow (default)
    config:
      robot: hrp4
      updateRobot: hrp4
      bodySensor: Accelerometer          # This observer only uses roll and pitch rotation information from this sensor along with a kinematic anchor point and the robot kinematics between the anchor frame and the floating base frame. The anchor frame is expected to be provided through a datastore callback (see below for details)
    # config:
    #   robot: e2dr
    #   updateRobot: e2dr
    #   bodySensor: Accelerometer

ObserverPipelines:
- name: HumanPipeline
  gui: true
  log: true
  observers:
  - type: Encoder                        # - Use an EncoderObserver
    config:
      robot: human
      updateRobot: human
      position: control # encoderValues            #    - Sets joint position from encoder sensor values (default)
      velocity: control # encoderFiniteDifferences #    - Computes joint velocities by finite differences  (default)
      computeFV: true
  - type: BodySensor                     # - Use a BodySensor observer
    update: true                        #   Do not update the real robot state
    gui: true                           #   Do not display in the gui
    config:
      robot: human
      bodySensor: FloatingBase           #   In simulation, the interface will fill this sensor with ground truth values
                                         #   The observer computes the position and velocity of the floating base
                                         #   by transforming the sensor measurements to the floating base frame
  # - type: Attitude
  #   config:
  #     robot: human
  #     bodySensor: Accelerometer
  # - type: KinematicInertial              # - Estimates the floating base state using the KinematicInertial observer
  #   update: true                         #   update the real robot instance from its results
  #   gui: true                            #   Displays the estimated velocity as an arrow (default)
  #   config:
  #     robot: human
  #     updateRobot: human
  #     bodySensor: Accelerometer


# Plugins: [XsensPlugin]
Plugins: [Replay, XsensPlugin, ForceShoePlugin, RobotModelUpdate, UDPPlugin]
Plugins: [Replay, XsensPlugin, ForceShoePlugin, RobotModelUpdate] #, UDPPlugin]

UDPPlugin:
  # Global configuration options for UDPPlugin
  # These are the default values used by the plugin, they may be overriden at controller's level,
  # See https://jrl-umi3218.github.io/mc_rtc/tutorials/usage/global-plugins.html for more details
  robots:
    hrp4:
      host: localhost
      port: 4444
      ignoredJoints:
        #joints: [CHEST_P, CHEST_Y, R_HIP_Y, R_HIP_R, R_HIP_P, L_HIP_Y, L_HIP_R, L_HIP_P, R_HAND_J0, R_HAND_J1, L_HAND_J0, L_HAND_J1, L_SHOULDER_R]
        joints: [R_HAND_J0, R_HAND_J1, L_HAND_J1, L_HAND_J0, L_WRIST_R, L_WRIST_P]
        values:
          L_WRIST_R: 0.0
          L_WRIST_P: 0.0


RobotModelUpdate:
  robot: human
# configuration for Replay plugin
Replay:
  # log: @MC_CONTROLLER_RUNTIME_INSTALL_PREFIX@/etc/trajectories/celia_suit1.bin
  # log: @MC_CONTROLLER_RUNTIME_INSTALL_PREFIX@/etc/trajectories/celia_nosuit2.bin #  forceshoes1.bin
  # log: @MC_CONTROLLER_RUNTIME_INSTALL_PREFIX@/etc/trajectories/celia_suit3.bin
  # log: @MC_CONTROLLER_RUNTIME_INSTALL_PREFIX@/etc/trajectories/celia_suit2.bin
  # log: @MC_CONTROLLER_RUNTIME_INSTALL_PREFIX@/etc/trajectories/forceshoes_celia.bin
  # log: @MC_CONTROLLER_RUNTIME_INSTALL_PREFIX@/etc/trajectories/standup.bin
  # log: @MC_CONTROLLER_RUNTIME_INSTALL_PREFIX@/etc/trajectories/forceshoes1.bin
  log: @MC_CONTROLLER_RUNTIME_INSTALL_PREFIX@/etc/trajectories/celia17nov/suit2.bin
  with-inputs: false
  with-outputs: false
  with-gui-inputs: false
  with-datastore-config: @MC_CONTROLLER_RUNTIME_INSTALL_PREFIX@/etc/trajectories/log-to-datastore.yaml


measuredPerson:
  # mass: 42 # Wanchen
  mass: 52 # Celia
  withSuit: true        # 10kg
  # withSuit: false
  withShoes: true       # 2*1.1kg
  # withShoes: false
  withLegs: false        # 2*2.3kg
  # withLegs: false
  withWrists: false      # 2*1.5kg

Omega:
  WithVerticalAcc: true

handContactsForBalance: false

filteredDerivation: true

ForceShoes:
  liveMode: false #add function to wait for xsens and force shoes sync in replays

# configuration for XsensHuman state
Xsens:
  liveMode: false
  human:
    bodies:
      HipsLink:
        segment: "Pelvis"
        offset:
          # translation: [0.05, 0, 0.1]
          translation: [0, 0, 0]
      TorsoLink:
        segment: "T8" # Sternum
        offset:
          # translation: [0, 0, -0.31] # torso is 31cm higher than pelvis for celia model, but urdf orig is same as pelvis
          # translation: [0.1, 0, -0.27]
          translation: [0, 0, 0]
          rotation: [0, 0, 0]
      HeadLink:
        segment: "Head"
        offset:
          translation: [0, 0, 0]
          rotation: [0, 0, 0]
      # Getting rid of shoulder retargeting
      # torso2rshoulder_2: #might be 2 instead of 1
      #   segment: "Right Upper Arm"
      #   offset:
      #     translation: [0, 0.0, -0.05] # 5cm lower for celia model (whole arm)
      #     rotation: [0, 0, 0]
      # torso2rshoulder_1:
      #   segment: "Right Upper Arm"
      #   offset:
      #     translation: [0, -0.0, -0.05]
      #     rotation: [0, 0, 0]
      RForearmLink:
        segment: "Right Forearm"
        offset:
          translation: [0, 0, 0]
          rotation: [0, 0, 0]
      RHandLink:
        segment: "Right Hand"
        offset:
          translation: [0, 0, 0]
          rotation: [0, 0, 0]
      # torso2lshoulder_2:
      #   segment: "Left Upper Arm"
      #   offset:
      #     translation: [0, 0.0, -0.05] # 5cm lower for celia model (whole arm)
      #     rotation: [0, 0, 0]
      # torso2lshoulder_1:
      #   segment: "Left Upper Arm"
      #   offset:
      #     translation: [0, 0.0, -0.05]
      #     rotation: [0, 0, 0]
      LForearmLink:
        segment: "Left Forearm"
        offset:
          translation: [0, 0, 0]
          rotation: [0, 0, 0]
      LHandLink:
        segment: "Left Hand"
        offset:
          translation: [0, 0, 0]
          rotation: [0, 0, 0]
      RLegLink:
        segment: "Right Upper Leg"
        offset:
          # translation: [0, 0, -0.12] # 10cm lower for celia
          translation: [0, 0, 0]
          rotation: [0, 0, 0]
      RShinLink:
        segment: "Right Lower Leg"
        offset:
          translation: [0, 0, 0] # 5cm higher for celia
          rotation: [0, 0, 0]
      RAnkleLink:
        segment: "Right Foot"
        offset:
          translation: [0, 0, 0]
          rotation: [0, 0, 0]
      LLegLink:
        segment: "Left Upper Leg"
        offset:
          # translation: [0, 0, -0.12]
          translation: [0, 0, 0]
          rotation: [0, 0, 0]
      LShinLink:
        segment: "Left Lower Leg"
        offset:
          translation: [0, 0, 0] # 5cm higher for celia
          rotation: [0, 0, 0]
      LAnkleLink:
        segment: "Left Foot"
        offset:
          translation: [0, 0, 0]
          rotation: [0, 0, 0]
